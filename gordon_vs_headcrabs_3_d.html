<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Gordon Freeman vs Headcrabs — Pixel FPS</title>
<style>
body { margin:0; overflow:hidden; background:black; }
#hud { position:fixed; bottom:20px; left:20px; color:#0f0; font-family:Arial, sans-serif; font-size:18px; z-index:1000; }
#ammo { margin-top:5px; }
#hint { position:fixed; bottom:20px; right:20px; color:white; font-family:Arial, sans-serif; opacity:0.9; z-index:1000; }
#overlay { position:fixed; left:0; top:0; width:100%; height:100%; display:flex; align-items:center; justify-content:center; font-family:Arial, sans-serif; color:#fff; font-size:36px; z-index:2000; pointer-events:none; }
#overlay.hidden{ display:none }
canvas { image-rendering: pixelated; image-rendering: crisp-edges; filter: contrast(1.3) saturate(1.2) hue-rotate(-3deg) blur(0.4px); }
</style>
</head>
<body>
<div id="hud">HP: <span id="hp">100</span><br><span id="ammo">Ammo: 30 / 90</span></div>
<div id="hint">Click to start • WASD - move • Mouse - look • LMB - shoot • R - reload</div>
<div id="overlay" class="hidden"></div>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script>
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x770000);
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2000);
camera.position.set(0, 2, 0);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);
scene.add(new THREE.AmbientLight(0xffffff,1.0));
const dirLight = new THREE.DirectionalLight(0xffffff,1.0);
dirLight.position.set(30,50,20);
scene.add(dirLight);
const ROOM_SIZE = 200;
scene.add(new THREE.Mesh(new THREE.BoxGeometry(ROOM_SIZE,20,ROOM_SIZE), new THREE.MeshStandardMaterial({color:0x770000,side:THREE.BackSide})));
const floor = new THREE.Mesh(new THREE.PlaneGeometry(ROOM_SIZE,ROOM_SIZE), new THREE.MeshStandardMaterial({color:0x550000}));
floor.rotation.x=-Math.PI/2;
scene.add(floor);
for(let i=0;i<200;i++){
    const crate=new THREE.Mesh(new THREE.BoxGeometry(2,2,2), new THREE.MeshStandardMaterial({color:0x333333}));
    crate.position.set((Math.random()-0.5)*(ROOM_SIZE-20),1,(Math.random()-0.5)*(ROOM_SIZE-20));
    crate.rotation.y=Math.random()*Math.PI*2;
    scene.add(crate);
}
const GRID=9;
const SPACING=ROOM_SIZE/(GRID+1);
for(let xi=1;xi<=GRID;xi++){
    for(let zi=1;zi<=GRID;zi++){
        const x=-ROOM_SIZE/2+SPACING*xi;
        const z=-ROOM_SIZE/2+SPACING*zi;
        const lampGroup=new THREE.Group();
        const bulb=new THREE.Mesh(new THREE.SphereGeometry(0.5,16,16),new THREE.MeshStandardMaterial({color:0xffffee,emissive:0xffffcc,emissiveIntensity:2}));
        bulb.position.set(x,9.2,z); lampGroup.add(bulb);
        const cord=new THREE.Mesh(new THREE.CylinderGeometry(0.04,0.04,1.4,8),new THREE.MeshStandardMaterial({color:0x111111}));
        cord.position.set(x,9.9,z); lampGroup.add(cord);
        scene.add(lampGroup);
        const bulbLight=new THREE.PointLight(0xfff7d6,1.2,ROOM_SIZE*0.8,2); bulbLight.position.set(x,9.2,z); scene.add(bulbLight);
    }
}
const rimLight=new THREE.PointLight(0xffffff,0.5,ROOM_SIZE*1.2); rimLight.position.set(0,9.9,0); scene.add(rimLight);
const keys={};
document.addEventListener('keydown',e=>keys[e.code]=true);
document.addEventListener('keyup',e=>keys[e.code]=false);
document.body.addEventListener('click',()=>document.body.requestPointerLock());
let yaw=0, pitch=0;
document.addEventListener('mousemove',e=>{
    if(document.pointerLockElement===document.body){
        yaw-=e.movementX*0.0025;
        pitch-=e.movementY*0.0025;
        pitch=Math.max(-Math.PI/2,Math.min(Math.PI/2,pitch));
        camera.quaternion.setFromEuler(new THREE.Euler(pitch, yaw, 0, 'YXZ'));
    }
});
const audioCtx=new(window.AudioContext||window.webkitAudioContext)();
function playTone(f,d,type='sine',v=0.1){ try{ const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type=type; o.frequency.value=f; g.gain.value=v; o.connect(g); g.connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime+d); }catch(e){} }
const weapon=new THREE.Mesh(new THREE.BoxGeometry(0.2,0.2,1.1),new THREE.MeshStandardMaterial({color:0x222222}));
weapon.position.set(0,-0.2,-0.6); camera.add(weapon);
scene.add(camera);
let ammo=30,reserve=90,hp=100,gameOver=false,lastDamage=0;
function updateHUD(){ document.getElementById('hp').innerText=hp; document.getElementById('ammo').innerText=`Ammo: ${ammo} / ${reserve}`;}
updateHUD();
function reload(){ if(ammo>=30||reserve<=0||gameOver) return; playTone(200,0.15,'sawtooth',0.08); const n=30-ammo; const t=Math.min(n,reserve); setTimeout(()=>{ ammo+=t; reserve-=t; updateHUD(); },800);}
document.addEventListener('keydown',e=>{ if(e.code==='KeyR') reload();});
const bullets=[];
function shoot(){ if(gameOver) return; if(ammo<=0){ playTone(120,0.05,'square',0.05); return;} ammo--; updateHUD(); playTone(800,0.08,'square',0.12); const b=new THREE.Mesh(new THREE.SphereGeometry(0.05,8,8), new THREE.MeshBasicMaterial({color:0xffff00})); b.position.copy(camera.position); b.direction=new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion); scene.add(b); bullets.push(b);}
document.addEventListener('mousedown', e=>{ if(e.button===0&&document.pointerLockElement===document.body) shoot();});
const enemies=[];
function spawnEnemy(){ if(gameOver) return; const c=new THREE.Group(); const body=new THREE.Mesh(new THREE.ConeGeometry(0.45,0.8,8),new THREE.MeshStandardMaterial({color:0x111111})); body.rotation.x=Math.PI; body.position.y=0.4; c.add(body); for(let i=0;i<4;i++){ const leg=new THREE.Mesh(new THREE.CylinderGeometry(0.05,0.05,0.6,6),new THREE.MeshStandardMaterial({color:0x111111})); leg.position.set(Math.cos(i*Math.PI/2)*0.3,0.2,Math.sin(i*Math.PI/2)*0.3); leg.rotation.z=(i%2===0?Math.PI/3:-Math.PI/3); c.add(leg);} c.position.set((Math.random()-0.5)*(ROOM_SIZE-30),0.45,(Math.random()-0.5)*(ROOM_SIZE-30)); scene.add(c); enemies.push(c);}
setInterval(spawnEnemy,1200);
function doDamage(a){ const n=performance.now(); if(n-lastDamage<500) return; lastDamage=n; hp=Math.max(0,hp-a); playTone(160,0.12,'sawtooth',0.14); updateHUD(); const ov=document.getElementById('overlay'); ov.innerText=''; ov.style.background='rgba(150,0,0,0.25)'; ov.classList.remove('hidden'); setTimeout(()=>{ if(!gameOver) ov.classList.add('hidden'); ov.style.background=''; },200); if(hp<=0){ gameOver=true; const overlay=document.getElementById('overlay'); overlay.innerText='GAME OVER'; overlay.style.background='rgba(0,0,0,0.6)'; overlay.style.pointerEvents='auto'; overlay.classList.remove('hidden');}}
function animate(){ requestAnimationFrame(animate); const s=0.2; const d=new THREE.Vector3(); camera.getWorldDirection(d); d.y=0; d.normalize(); const r=new THREE.Vector3().crossVectors(d,new THREE.Vector3(0,1,0)); if(keys['KeyW']) camera.position.add(d.clone().multiplyScalar(s)); if(keys['KeyS']) camera.position.add(d.clone().multiplyScalar(-s)); if(keys['KeyA']) camera.position.add(r.clone().multiplyScalar(-s)); if(keys['KeyD']) camera.position.add(r.clone().multiplyScalar(s)); bullets.forEach((b,i)=>{ b.position.add(b.direction.clone().multiplyScalar(1.2)); if(b.position.distanceTo(camera.position)>500){ scene.remove(b); bullets.splice(i,1); } }); enemies.forEach((e,ei)=>{ const tp=camera.position.clone().sub(e.position); const dist=tp.length(); tp.normalize(); e.position.add(tp.multiplyScalar(0.04)); if(dist<1.6){ doDamage(10); scene.remove(e); enemies.splice(ei,1); return;} bullets.forEach((b,bi)=>{ if(b.position.distanceTo(e.position)<0.6){ playTone(300,0.06,'sine',0.08); scene.remove(e); scene.remove(b); enemies.splice(ei,1); bullets.splice(bi,1); } }); }); renderer.render(scene,camera);}
animate();
window.addEventListener('resize',()=>{ camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth,window.innerHeight);});
</script>
</body>
</html>
